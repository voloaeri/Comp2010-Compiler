\section{Introduction}

This reports will explain how we implemented variable folding for Java bytecode. Performing folding at compile time can result in an extensive reduction of instructions in the bytecode and therefore in an improvement of the overall performance of a program.

The optimization is implemented into a given code framework. This framework contains both tests and a basic implementation so that we could concentrate solely on the optimization. Part of the given implementation is the \texttt{optimize} method is called once for every \texttt{.class} file. It initiates the optimization process for every method in the given file. 

In the following section \ref{sec:classification}, we will provide further explanation on how we classified the different bytecode instruction types. It is followed by a detailed description of out most important functions (section \ref{sec:description}). Since every in section \ref{sec:classification} described instruction type is handled differently, every particular explanation is supported by an appropriate flow chart diagram. The optimization includes an extensive pattern matching phase. Thus, only the most important functions are described. There exist, however, an enumeration type (\texttt{OperationType}) as well as plenty help functions that make the pattern matching easier and more modular. Since they are self-explanatory and annotated with comments, we relinquish a detailed description and concentrate more on the algorithmic aspects. The report closes with an example showing the difference between unoptimized and unoptimized code (section \ref{sec:example}).