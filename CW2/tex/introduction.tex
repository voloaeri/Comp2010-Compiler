\section{Introduction}

This report will explain how we implemented variable folding for Java bytecode. Performing folding at compile time can result in an extensive reduction of instructions in the bytecode and therefore in an improvement of the overall performance of a program.

The optimization is implemented into a given code framework. This framework contains both tests and a basic implementation so that we could concentrate solely on the optimization. Part of the given implementation is the \texttt{optimize} method which is called once for every \texttt{.class} file. It initiates the optimization process for every method in the given file. 

In the following section \ref{sec:classification}, we will provide further explanation on how we classified the different bytecode instruction types. It is followed by a detailed description of our most important functions (section \ref{sec:description}). The different instruction types in section \ref{sec:classification} are all handled differently. Thus, the explanations of how they are handled are supported by flow chart diagrams. The optimization includes an extensive pattern matching phase. Thus, only the most important functions are described. There exists, however, an enumeration type (\texttt{OperationType}) as well as plenty help functions that make the pattern matching easier and more modular. Since they are self-explanatory and annotated with comments, we relinquish a detailed description and concentrate more on the algorithmic aspects. The report closes with an example showing the difference between unoptimized and unoptimized code (section \ref{sec:example}).